From ac1b8c3067716d67cc9c0c184d5b15ac27fd945a Mon Sep 17 00:00:00 2001
From: Vaxry <vaxry@vaxry.net>
Date: Sat, 21 Sep 2024 00:24:39 +0100
Subject: [PATCH] core: add explicit casts to wl_proxy* for clang

fixes #261
---
 src/core/PortalManager.cpp     | 19 +++++++++----------
 src/shared/ToplevelManager.cpp |  5 +++--
 2 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/src/core/PortalManager.cpp b/src/core/PortalManager.cpp
index e8878ed..2a7e142 100644
--- a/src/core/PortalManager.cpp
+++ b/src/core/PortalManager.cpp
@@ -53,24 +53,24 @@ void CPortalManager::onGlobal(uint32_t name, const char* interface, uint32_t ver
     Debug::log(LOG, " | Got interface: {} (ver {})", INTERFACE, version);
 
     if (INTERFACE == zwlr_screencopy_manager_v1_interface.name && m_sPipewire.loop) {
-        m_sPortals.screencopy = std::make_unique<CScreencopyPortal>(
-            makeShared<CCZwlrScreencopyManagerV1>(wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &zwlr_screencopy_manager_v1_interface, version)));
+        m_sPortals.screencopy = std::make_unique<CScreencopyPortal>(makeShared<CCZwlrScreencopyManagerV1>(
+            (wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &zwlr_screencopy_manager_v1_interface, version)));
     }
 
     if (INTERFACE == hyprland_global_shortcuts_manager_v1_interface.name) {
         m_sPortals.globalShortcuts = std::make_unique<CGlobalShortcutsPortal>(makeShared<CCHyprlandGlobalShortcutsManagerV1>(
-            wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &hyprland_global_shortcuts_manager_v1_interface, version)));
+            (wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &hyprland_global_shortcuts_manager_v1_interface, version)));
     }
 
     else if (INTERFACE == hyprland_toplevel_export_manager_v1_interface.name) {
         m_sWaylandConnection.hyprlandToplevelMgr = makeShared<CCHyprlandToplevelExportManagerV1>(
-            wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &hyprland_toplevel_export_manager_v1_interface, version));
+            (wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &hyprland_toplevel_export_manager_v1_interface, version));
     }
 
     else if (INTERFACE == wl_output_interface.name) {
         const auto POUTPUT = m_vOutputs
-                                 .emplace_back(std::make_unique<SOutput>(
-                                     makeShared<CCWlOutput>(wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &wl_output_interface, version))))
+                                 .emplace_back(std::make_unique<SOutput>(makeShared<CCWlOutput>(
+                                     (wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &wl_output_interface, version))))
                                  .get();
         POUTPUT->id = name;
     }
@@ -82,7 +82,7 @@ void CPortalManager::onGlobal(uint32_t name, const char* interface, uint32_t ver
         }
 
         m_sWaylandConnection.linuxDmabuf =
-            makeShared<CCZwpLinuxDmabufV1>(wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &zwp_linux_dmabuf_v1_interface, version));
+            makeShared<CCZwpLinuxDmabufV1>((wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &zwp_linux_dmabuf_v1_interface, version));
         m_sWaylandConnection.linuxDmabufFeedback = makeShared<CCZwpLinuxDmabufFeedbackV1>(m_sWaylandConnection.linuxDmabuf->sendGetDefaultFeedback());
 
         m_sWaylandConnection.linuxDmabufFeedback->setMainDevice([this](CCZwpLinuxDmabufFeedbackV1* r, wl_array* device_arr) {
@@ -180,9 +180,8 @@ void CPortalManager::onGlobal(uint32_t name, const char* interface, uint32_t ver
 
     }
 
-    else if (INTERFACE == wl_shm_interface.name) {
-        m_sWaylandConnection.shm = makeShared<CCWlShm>(wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &wl_shm_interface, version));
-    }
+    else if (INTERFACE == wl_shm_interface.name)
+        m_sWaylandConnection.shm = makeShared<CCWlShm>((wl_proxy*)wl_registry_bind((wl_registry*)m_sWaylandConnection.registry->resource(), name, &wl_shm_interface, version));
 
     else if (INTERFACE == zwlr_foreign_toplevel_manager_v1_interface.name) {
         m_sHelpers.toplevel = std::make_unique<CToplevelManager>(name, version);
diff --git a/src/shared/ToplevelManager.cpp b/src/shared/ToplevelManager.cpp
index b947ca5..f998d13 100644
--- a/src/shared/ToplevelManager.cpp
+++ b/src/shared/ToplevelManager.cpp
@@ -34,8 +34,9 @@ void CToplevelManager::activate() {
     if (m_pManager || m_iActivateLocks < 1)
         return;
 
-    m_pManager = makeShared<CCZwlrForeignToplevelManagerV1>(wl_registry_bind((wl_registry*)g_pPortalManager->m_sWaylandConnection.registry->resource(), m_sWaylandConnection.name,
-                                                                             &zwlr_foreign_toplevel_manager_v1_interface, m_sWaylandConnection.version));
+    m_pManager =
+        makeShared<CCZwlrForeignToplevelManagerV1>((wl_proxy*)wl_registry_bind((wl_registry*)g_pPortalManager->m_sWaylandConnection.registry->resource(), m_sWaylandConnection.name,
+                                                                               &zwlr_foreign_toplevel_manager_v1_interface, m_sWaylandConnection.version));
 
     m_pManager->setToplevel([this](CCZwlrForeignToplevelManagerV1* r, wl_proxy* newHandle) {
         Debug::log(TRACE, "[toplevel] New toplevel at {}", (void*)newHandle);
